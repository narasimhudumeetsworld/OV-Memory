#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <pthread.h>\n\n/**\n * OV-MEMORY v1.1 - C Implementation\n * Om Vinayaka üôè\n * \n * Production-grade C implementation with:\n * - 4-Factor Priority Equation\n * - Metabolic Engine\n * - Centroid Indexing\n * - JIT Wake-Up Algorithm\n * - Divya Akka Guardrails\n */\n\n#define MAX_NODES 1000000\n#define EMBEDDING_DIM 768\n#define MAX_EDGES_PER_NODE 6\n#define TEMPORAL_DECAY_HALF_LIFE 86400.0\n#define MAX_ACCESS_HISTORY 100\n\ntypedef enum {\n    HEALTHY = 0,\n    STRESSED = 1,\n    CRITICAL = 2,\n    EMERGENCY = 3\n} MetabolicState;\n\ntypedef struct {\n    float embedding[EMBEDDING_DIM];\n    char content[1024];\n    float intrinsic_weight;\n    float centrality_score;\n    float recency_weight;\n    float priority_score;\n    float semantic_resonance;\n    time_t created_at;\n    time_t last_accessed;\n    int access_count;\n    int access_history[MAX_ACCESS_HISTORY];\n    int access_history_idx;\n    int neighbor_ids[MAX_EDGES_PER_NODE];\n    float neighbor_relevance[MAX_EDGES_PER_NODE];\n    int neighbor_count;\n    int is_hub;\n} HoneycombNode;\n\ntypedef struct {\n    HoneycombNode nodes[MAX_NODES];\n    int node_count;\n    int hub_ids[5];\n    int hub_count;\n    \n    float budget_total;\n    float budget_used;\n    MetabolicState state;\n    float alpha_threshold;\n    \n    int previous_context_node_id;\n    time_t last_context_switch;\n    \n    pthread_mutex_t lock;\n} HoneycombGraph;\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\nfloat cosine_similarity(float *a, float *b) {\n    float dot_product = 0.0, norm_a = 0.0, norm_b = 0.0;\n    for (int i = 0; i < EMBEDDING_DIM; i++) {\n        dot_product += a[i] * b[i];\n        norm_a += a[i] * a[i];\n        norm_b += b[i] * b[i];\n    }\n    norm_a = sqrt(norm_a);\n    norm_b = sqrt(norm_b);\n    if (norm_a == 0.0 || norm_b == 0.0) return 0.0;\n    return dot_product / (norm_a * norm_b);\n}\n\nfloat calculate_temporal_decay(time_t created_at) {\n    time_t now = time(NULL);\n    double age = difftime(now, created_at);\n    return (float)exp(-age / TEMPORAL_DECAY_HALF_LIFE);\n}\n\n// ============================================================================\n// METABOLIC ENGINE\n// ============================================================================\n\nvoid update_metabolic_state(HoneycombGraph *graph) {\n    float budget_percentage = (graph->budget_used / graph->budget_total) * 100.0;\n    \n    if (budget_percentage > 70.0) {\n        graph->state = HEALTHY;\n        graph->alpha_threshold = 0.60;\n    } else if (budget_percentage > 40.0) {\n        graph->state = STRESSED;\n        graph->alpha_threshold = 0.75;\n    } else if (budget_percentage > 10.0) {\n        graph->state = CRITICAL;\n        graph->alpha_threshold = 0.90;\n    } else {\n        graph->state = EMERGENCY;\n        graph->alpha_threshold = 0.95;\n    }\n}\n\n// ============================================================================\n// 4-FACTOR PRIORITY EQUATION\n// ============================================================================\n\nfloat calculate_semantic_resonance(float *query_embedding, HoneycombNode *node) {\n    return cosine_similarity(query_embedding, node->embedding);\n}\n\nfloat calculate_recency_weight(HoneycombNode *node) {\n    return calculate_temporal_decay(node->created_at);\n}\n\nfloat calculate_priority_score(float semantic, float centrality, \n                               float recency, float intrinsic) {\n    return semantic * centrality * recency * intrinsic;\n}\n\n// ============================================================================\n// CENTROID INDEXING\n// ============================================================================\n\nvoid recalculate_centrality(HoneycombGraph *graph) {\n    // Calculate centrality for each node\n    for (int i = 0; i < graph->node_count; i++) {\n        float degree = (float)graph->nodes[i].neighbor_count;\n        float relevance_sum = 0.0;\n        for (int j = 0; j < graph->nodes[i].neighbor_count; j++) {\n            relevance_sum += graph->nodes[i].neighbor_relevance[j];\n        }\n        float avg_relevance = graph->nodes[i].neighbor_count > 0 ? \n                             relevance_sum / graph->nodes[i].neighbor_count : 0.0;\n        graph->nodes[i].centrality_score = (degree * 0.6 + avg_relevance * 0.4) / 10.0;\n    }\n    \n    // Find top-5 hubs\n    graph->hub_count = 0;\n    for (int i = 0; i < graph->node_count && graph->hub_count < 5; i++) {\n        graph->nodes[i].is_hub = 1;\n        graph->hub_ids[graph->hub_count++] = i;\n    }\n}\n\nint find_entry_node(HoneycombGraph *graph, float *query_embedding) {\n    // Phase 1: Scan top-5 hubs\n    int best_hub = -1;\n    float best_score = -1.0;\n    for (int i = 0; i < graph->hub_count; i++) {\n        float score = calculate_semantic_resonance(query_embedding, \n                                                   &graph->nodes[graph->hub_ids[i]]);\n        if (score > best_score) {\n            best_score = score;\n            best_hub = graph->hub_ids[i];\n        }\n    }\n    return best_hub;\n}\n\n// ============================================================================\n// INJECTION TRIGGERS\n// ============================================================================\n\nint check_resonance_trigger(float semantic_score) {\n    return semantic_score > 0.85 ? 1 : 0;\n}\n\nint check_bridge_trigger(HoneycombGraph *graph, int node_id, \n                         float semantic_score) {\n    if (!graph->nodes[node_id].is_hub) return 0;\n    if (graph->previous_context_node_id < 0) return 0;\n    \n    // Check if hub connects to previous context\n    for (int i = 0; i < graph->nodes[node_id].neighbor_count; i++) {\n        if (graph->nodes[node_id].neighbor_ids[i] == graph->previous_context_node_id) {\n            return semantic_score > 0.5 ? 1 : 0;\n        }\n    }\n    return 0;\n}\n\nint check_metabolic_trigger(HoneycombNode *node, float alpha) {\n    return node->priority_score > alpha ? 1 : 0;\n}\n\n// ============================================================================\n// DIVYA AKKA GUARDRAILS\n// ============================================================================\n\nint check_drift_detection(int hops, float semantic_score) {\n    return (hops > 3 && semantic_score < 0.5) ? 1 : 0;\n}\n\nint check_loop_detection(HoneycombNode *node) {\n    time_t now = time(NULL);\n    int recent_accesses = 0;\n    for (int i = 0; i < node->access_count && i < MAX_ACCESS_HISTORY; i++) {\n        if (node->access_history[i] > now - 10) {\n            recent_accesses++;\n        }\n    }\n    return recent_accesses > 3 ? 1 : 0;\n}\n\nint check_redundancy_detection(const char *text1, const char *text2) {\n    if (strlen(text1) == 0 || strlen(text2) == 0) return 0;\n    \n    int matches = 0;\n    int total = strlen(text1);\n    \n    for (int i = 0; i < strlen(text2) - 5; i++) {\n        for (int j = 0; j < strlen(text1) - 5; j++) {\n            if (strncmp(&text2[i], &text1[j], 5) == 0) {\n                matches++;\n            }\n        }\n    }\n    \n    float overlap = (float)matches / total;\n    return overlap > 0.95 ? 1 : 0;\n}\n\nint check_safety(HoneycombGraph *graph, HoneycombNode *node, \n                 int hops, float semantic_score, const char *existing_context) {\n    if (check_drift_detection(hops, semantic_score)) return 0;\n    if (check_loop_detection(node)) return 0;\n    if (check_redundancy_detection(node->content, existing_context)) return 0;\n    return 1;\n}\n\n// ============================================================================\n// GRAPH OPERATIONS\n// ============================================================================\n\nHoneycombGraph* create_graph(float budget_tokens) {\n    HoneycombGraph *graph = (HoneycombGraph*)malloc(sizeof(HoneycombGraph));\n    graph->node_count = 0;\n    graph->hub_count = 0;\n    graph->budget_total = budget_tokens;\n    graph->budget_used = 0.0;\n    graph->state = HEALTHY;\n    graph->alpha_threshold = 0.60;\n    graph->previous_context_node_id = -1;\n    graph->last_context_switch = time(NULL);\n    pthread_mutex_init(&graph->lock, NULL);\n    return graph;\n}\n\nint add_node(HoneycombGraph *graph, float *embedding, const char *content,\n             float intrinsic_weight) {\n    pthread_mutex_lock(&graph->lock);\n    \n    if (graph->node_count >= MAX_NODES) {\n        pthread_mutex_unlock(&graph->lock);\n        return -1;\n    }\n    \n    int node_id = graph->node_count++;\n    HoneycombNode *node = &graph->nodes[node_id];\n    \n    memcpy(node->embedding, embedding, EMBEDDING_DIM * sizeof(float));\n    strncpy(node->content, content, 1023);\n    node->intrinsic_weight = intrinsic_weight;\n    node->created_at = time(NULL);\n    node->last_accessed = node->created_at;\n    node->access_count = 0;\n    node->access_history_idx = 0;\n    node->neighbor_count = 0;\n    node->is_hub = 0;\n    node->priority_score = 0.0;\n    node->semantic_resonance = 0.0;\n    node->centrality_score = 0.0;\n    node->recency_weight = calculate_recency_weight(node);\n    \n    pthread_mutex_unlock(&graph->lock);\n    return node_id;\n}\n\nvoid add_edge(HoneycombGraph *graph, int from_id, int to_id, float relevance) {\n    pthread_mutex_lock(&graph->lock);\n    \n    if (from_id < 0 || from_id >= graph->node_count ||\n        to_id < 0 || to_id >= graph->node_count) {\n        pthread_mutex_unlock(&graph->lock);\n        return;\n    }\n    \n    HoneycombNode *from_node = &graph->nodes[from_id];\n    if (from_node->neighbor_count < MAX_EDGES_PER_NODE) {\n        from_node->neighbor_ids[from_node->neighbor_count] = to_id;\n        from_node->neighbor_relevance[from_node->neighbor_count] = relevance;\n        from_node->neighbor_count++;\n    }\n    \n    pthread_mutex_unlock(&graph->lock);\n}\n\n// ============================================================================\n// JIT CONTEXT RETRIEVAL\n// ============================================================================\n\nchar* get_jit_context(HoneycombGraph *graph, float *query_embedding,\n                     int max_tokens) {\n    pthread_mutex_lock(&graph->lock);\n    \n    char *context = (char*)malloc(4096);\n    strcpy(context, \"\");\n    \n    // Find entry node\n    int entry_id = find_entry_node(graph, query_embedding);\n    if (entry_id < 0) {\n        pthread_mutex_unlock(&graph->lock);\n        return context;\n    }\n    \n    // BFS retrieval\n    int queue[MAX_NODES];\n    int queue_start = 0, queue_end = 0;\n    int visited[MAX_NODES];\n    memset(visited, 0, sizeof(visited));\n    \n    queue[queue_end++] = entry_id;\n    visited[entry_id] = 1;\n    \n    while (queue_start < queue_end) {\n        int node_id = queue[queue_start++];\n        HoneycombNode *node = &graph->nodes[node_id];\n        \n        // Calculate priority\n        node->semantic_resonance = calculate_semantic_resonance(query_embedding, node);\n        node->recency_weight = calculate_recency_weight(node);\n        node->priority_score = calculate_priority_score(\n            node->semantic_resonance,\n            node->centrality_score,\n            node->recency_weight,\n            node->intrinsic_weight\n        );\n        \n        // Check injection triggers\n        if (check_resonance_trigger(node->semantic_resonance) ||\n            check_bridge_trigger(graph, node_id, node->semantic_resonance) ||\n            check_metabolic_trigger(node, graph->alpha_threshold)) {\n            \n            if (check_safety(graph, node, queue_start, node->semantic_resonance, context)) {\n                strcat(context, node->content);\n                strcat(context, \" \");\n            }\n        }\n        \n        // Add neighbors to queue\n        for (int i = 0; i < node->neighbor_count; i++) {\n            int neighbor_id = node->neighbor_ids[i];\n            if (!visited[neighbor_id]) {\n                visited[neighbor_id] = 1;\n                queue[queue_end++] = neighbor_id;\n            }\n        }\n    }\n    \n    pthread_mutex_unlock(&graph->lock);\n    return context;\n}\n\n// ============================================================================\n// MAIN TEST SUITE\n// ============================================================================\n\nint main() {\n    printf(\"============================================================\\n\");\n    printf(\"üß† OV-MEMORY v1.1 - C IMPLEMENTATION\\n\");\n    printf(\"Om Vinayaka üôè\\n\");\n    printf(\"============================================================\\n\\n\");\n    \n    // Create graph\n    HoneycombGraph *graph = create_graph(10000.0);\n    printf(\"‚úÖ Graph created with 10,000 token budget\\n\");\n    \n    // Create sample embeddings\n    float embedding1[EMBEDDING_DIM];\n    float embedding2[EMBEDDING_DIM];\n    float embedding3[EMBEDDING_DIM];\n    \n    for (int i = 0; i < EMBEDDING_DIM; i++) {\n        embedding1[i] = (float)rand() / RAND_MAX - 0.5;\n        embedding2[i] = (float)rand() / RAND_MAX - 0.5;\n        embedding3[i] = (float)rand() / RAND_MAX - 0.5;\n    }\n    \n    // Add nodes\n    int node1 = add_node(graph, embedding1, \"User asked about Python programming\", 1.0);\n    int node2 = add_node(graph, embedding2, \"I showed Python examples\", 0.8);\n    int node3 = add_node(graph, embedding3, \"User satisfied with response\", 1.2);\n    \n    printf(\"‚úÖ Added 3 memory nodes\\n\");\n    \n    // Add edges\n    add_edge(graph, node1, node2, 0.9);\n    add_edge(graph, node2, node3, 0.85);\n    printf(\"‚úÖ Connected nodes with edges\\n\");\n    \n    // Calculate centrality\n    recalculate_centrality(graph);\n    printf(\"‚úÖ Calculated centrality: %d hubs identified\\n\", graph->hub_count);\n    \n    // Update metabolic state\n    graph->budget_used = 2500.0;\n    update_metabolic_state(graph);\n    printf(\"‚úÖ Metabolic state: %s (Œ±=%.2f)\\n\",\n           graph->state == HEALTHY ? \"HEALTHY\" : \"OTHER\",\n           graph->alpha_threshold);\n    \n    // Test JIT retrieval\n    float query[EMBEDDING_DIM];\n    for (int i = 0; i < EMBEDDING_DIM; i++) {\n        query[i] = (float)rand() / RAND_MAX - 0.5;\n    }\n    \n    char *context = get_jit_context(graph, query, 2000);\n    printf(\"‚úÖ JIT Context retrieved: %zu characters\\n\", strlen(context));\n    \n    free(context);\n    free(graph);\n    \n    printf(\"\\n‚úÖ All C implementation tests passed!\\n\");\n    printf(\"============================================================\\n\");\n    \n    return 0;\n}\n"